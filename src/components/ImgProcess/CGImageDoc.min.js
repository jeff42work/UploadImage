/* eslint-disable */
/*
 * CGImageDoc.js
 * 版本1.0.22.929
 * http://www.changingtec.com
 *
 * Copyright © 2018 全景軟體股份有限公司
 */
import jsfeat from "./jsfeat-min.js";
import points from "./getPoints.min.js";
import fx from "./glfx.js";
// String.prototype.format = function () {
//   for (k in ((a = this), arguments)) a = a.replace(new RegExp("\\{" + k + "\\}", "g"), arguments[k]);
//   return a;
// };
var cgimg = cgimg || {
  KeystoneCorrectionViewCtrl: function (t) {
    (this.InitialCanvas = function (t) {
      (n = document.createElement("canvas")), (o = n.getContext("2d")), (r = document.createElement("canvas")), (h = r.getContext("2d"));
      var e = g.width,
        a = g.height;
      (r.width = e),
        (r.height = a),
        (n.width = e),
        (n.height = a),
        (c = [
          [10, 10],
          [g.width - 10, 10],
          [g.width - 10, g.height - 10],
          [10, g.height - 10],
        ]),
        o.drawImage(t, 0, 0, n.width, n.height),
        u(h, c),
        s(l, o, h),
        console.log("canvas initial");
    }),
      (this.GetPoints = function () {
        return c;
      }),
      (this.GetScalePoints = function (t) {
        var e = t.width / g.width,
          t = t.height / g.height;
        return [
          [c[0][0] * e, c[0][1] * t],
          [c[1][0] * e, c[1][1] * t],
          [c[2][0] * e, c[2][1] * t],
          [c[3][0] * e, c[3][1] * t],
        ];
      }),
      (this.SetScalePoints = function (t, e) {
        var a = e.width / g.width,
          e = e.height / g.height,
          e = [
            [t[0][0] / a, t[0][1] / e],
            [t[1][0] / a, t[1][1] / e],
            [t[2][0] / a, t[2][1] / e],
            [t[3][0] / a, t[3][1] / e],
          ];
        u(h, (c = e)), s(l, o, h);
      }),
      (this.Release = function () {
        console.log("release drag drop control"),
          g.removeEventListener("mousedown", E),
          g.removeEventListener("mousemove", I),
          g.removeEventListener("mouseup", C),
          g.removeEventListener("touchstart", M),
          g.removeEventListener("touchcancel", b),
          g.removeEventListener("touchmove", L),
          g.removeEventListener("touchend", D);
      });
    function e(t) {
      var e = t.target.getBoundingClientRect();
      return { x: t.clientX - e.left, y: t.clientY - e.top };
    }
    function a(t) {
      var e = t.target.getBoundingClientRect();
      return { x: t.touches[0].pageX - (e.left + window.scrollX), y: t.touches[0].pageY - (e.top + window.scrollY) };
    }
    function i(t, e, a) {
      var n = e[0] - t[0],
        o = e[1] - t[1],
        r = o / n,
        i = { x: 0, y: 0 };
      return (
        0 == o
          ? ((i.y = t[1]), (i.x = 0 < n ? t[0] + a : t[0] - a))
          : 0 == n
          ? ((i.x = t[0]), (i.y = 0 < o ? t[1] + a : t[1] - a))
          : ((a = Math.sqrt(Math.pow(a, 2) / (1 + Math.pow(r, 2)))),
            (i.x = a + t[0]),
            (i.y = r * (i.x - t[0]) + t[1]),
            (Math.min(t[0], e[0]) <= i.x && i.x <= Math.max(t[0], e[0]) && Math.min(t[1], e[1]) <= i.y && i.y <= Math.max(t[1], e[1])) ||
              ((i.x = -1 * a + t[0]), (i.y = r * (i.x - t[0]) + t[1])),
            (i.x = 0.001 * Math.round(1e3 * i.x)),
            (i.y = 0.001 * Math.round(1e3 * i.y))),
        i
      );
    }
    var n,
      o,
      r,
      h,
      c,
      g = document.getElementById(t),
      l = g.getContext("2d"),
      d = 0.1 * Math.min(g.width, g.height),
      s = function (t, e, a) {
        t.clearRect(0, 0, t.canvas.width, t.canvas.height), t.drawImage(e.canvas, 0, 0), t.drawImage(a.canvas, 0, 0);
      },
      u = function (t, e) {
        t.save(), t.clearRect(0, 0, t.canvas.width, t.canvas.height);
        for (var a = ["#ff0000", "#00ff00", "#eaff00", "#0000ff"], n = 0; n < 4; n++) {
          t.beginPath();
          var o = t.globalAlpha;
          (t.globalAlpha = 0.2), (t.fillStyle = a[n]), t.arc(e[n][0], e[n][1], d, 0, 2 * Math.PI), t.fill(), (t.globalAlpha = o);
        }
        for (n = 0; n < 4; n++) {
          t.save(), t.beginPath(), (t.lineWidth = "4"), (t.strokeStyle = a[n]), t.moveTo(e[n][0] * w, e[n][1] * w);
          var r = i(e[n], e[(n + 1) % 4], Math.floor(20 / w));
          t.lineTo(r.x * w, r.y * w), t.closePath(), t.stroke(), t.beginPath(), (t.lineWidth = "2"), (t.strokeStyle = "#ff0000");
          r = i([r.x, r.y], e[(n + 1) % 4], Math.floor(1 / w));
          t.moveTo(r.x * w, r.y * w),
            (r = i(e[(n + 1) % 4], e[n], Math.floor(20 / w))),
            t.lineTo(r.x * w, r.y * w),
            t.closePath(),
            t.stroke(),
            t.restore(),
            t.beginPath(),
            (t.lineWidth = "4"),
            (t.strokeStyle = a[(n + 1) % 4]),
            t.moveTo(r.x * w, r.y * w),
            t.lineTo(e[(n + 1) % 4][0] * w, e[(n + 1) % 4][1] * w),
            t.closePath(),
            t.stroke(),
            t.restore();
        }
      };
    function f(t) {
      for (var e = 0; e < 4; e++) {
        var a = c[e][0] * w,
          n = c[e][1] * w;
        if (Math.pow(Math.pow(a - t.x, 2) + Math.pow(n - t.y, 2), 0.5) <= 2 * d) {
          (x = e), (p = t), (y = [a, n]);
          break;
        }
      }
    }
    function m() {
      null != x && (l.clearRect(0, 0, g.width, g.height), u(h, c), s(l, o, h), (x = null));
    }
    function v(t) {
      var e;
      null != x &&
        ((e = t.x - p.x),
        (t = t.y - p.y),
        (c[x][0] = y[0] + e),
        (c[x][1] = y[1] + t),
        (e = c[x][0]),
        (t = c[x][1]),
        e < 0 && (c[x][0] = 0),
        t < 0 && (c[x][1] = 0),
        e >= g.width && (c[x][0] = g.width - 1),
        t >= g.height && (c[x][1] = g.height - 1),
        l.clearRect(0, 0, g.width, g.height),
        u(h, c),
        s(l, o, h));
    }
    var w = 1,
      x = null,
      p = null,
      y = null,
      E = function (t) {
        // console.log("on canvas mousedown"),
        t.preventDefault();
        t = e(t);
        f(t);
      };
    g.addEventListener("mousedown", E);
    var I = function (t) {
      // console.log("on canvas mousemove"),
      t.preventDefault();
      t = e(t);
      v(t);
    };
    g.addEventListener("mousemove", I);
    var C = function (t) {
      // console.log("on canvas mouseup"),
      t.preventDefault(), m();
    };
    g.addEventListener("mouseup", C);
    var M = function (t) {
      // console.log("on canvas touchstart"),
      t.preventDefault();
      t = a(t);
      f(t);
    };
    g.addEventListener("touchstart", M, !1);
    var b = function (t) {
      // console.log("on canvas touchcancel"),
      t.preventDefault(), m();
    };
    g.addEventListener("touchcancel", b, !1);
    var L = function (t) {
      // console.log("on canvas touchmove"),
      t.preventDefault();
      t = a(t);
      v(t);
    };
    g.addEventListener("touchmove", L, !1);
    var D = function (t) {
      // console.log("on canvas touchend"),
      t.preventDefault(), m();
    };
    g.addEventListener("touchend", D, !1);
  },
  PerspectiveTransform: function (t, e, a) {
    try {
      var n = fx.canvas();
    } catch (t) {
      return alert(t), null;
    }
    var o = [e[0][0], e[0][1], e[1][0], e[1][1], e[2][0], e[2][1], e[3][0], e[3][1]],
      r = n.texture(t),
      i = t.width,
      e = t.height,
      e = [0, 0, i, 0, i, e, 0, e];
    n.draw(r).perspective(o, e).update();
    (r = "org image參數:\r\n" + "width/height: " + t.width + ", " + t.height + "\r\n"),
      (t = "canvasPers參數\r\n" + "width/height: " + n.width + ", " + n.height + "\r\n");
    console.log(r), console.log(t);
    (o =
      "梯形校正座標(before):\r\n" +
      "左上: x=" +
      o[0] +
      ", y=" +
      o[1] +
      "\r\n" +
      "右上: x=" +
      o[2] +
      ", y=" +
      o[3] +
      "\r\n" +
      "右下: x=" +
      o[4] +
      ", y=" +
      o[5] +
      "\r\n" +
      "左下: x=" +
      o[6] +
      ", y=" +
      o[7] +
      "}\r\n"),
      (e =
        "梯形校正座標(after):\r\n" +
        "左上: x=" +
        e[0] +
        ", y=" +
        e[1] +
        "\r\n" +
        "右上: x=" +
        e[2] +
        ", y=" +
        e[3] +
        "\r\n" +
        "右下: x=" +
        e[4] +
        ", y=" +
        e[5] +
        "\r\n" +
        "左下: x=" +
        e[6] +
        ", y=" +
        e[7]) + "\r\n";
    console.log(o), console.log(e), console.log("image perspective transform end");
    (e = (function (t) {
      switch (t) {
        case "IDCard":
          return { width: 950, height: 566 };
        case "HealthInsuranceCard":
          return { width: 1004, height: 637 };
        case "DrivingLicense":
        case "DrivingLicenseOld":
          return { width: 1003, height: 708 };
        case "VehicleLicenseMotor":
          return { width: 791, height: 1098 };
        case "VehicleLicenseCar":
          return { width: 1712, height: 1198 };
        case "ResidentCertificate":
          return { width: 1004, height: 637 };
        case "Passport":
          return { width: 1476, height: 1039 };
        case "A4":
          return { width: 2482, height: 3510 };
        default:
          return alert("card type (" + t + ") not define"), { width: 400, height: 300 };
      }
    })(a)),
      (a = document.createElement("canvas"));
    return (a.width = e.width), (a.height = e.height), a.getContext("2d").drawImage(n, 0, 0, a.width, a.height), a;
  },
  CutImage: function (t, e) {
    var a = Math.min(Math.min(e[0][0], e[1][0]), Math.min(e[2][0], e[3][0])),
      n = Math.min(Math.min(e[0][1], e[1][1]), Math.min(e[2][1], e[3][1])),
      o = Math.max(Math.max(e[0][0], e[1][0]), Math.max(e[2][0], e[3][0])) + 1 - a,
      r = Math.max(Math.max(e[0][1], e[1][1]), Math.max(e[2][1], e[3][1])) + 1 - n,
      e = document.createElement("canvas");
    return (e.width = o), (e.height = r), e.getContext("2d").drawImage(t, a, n, o, r, 0, 0, o, r), e;
  },
  CardEdgeDetection: function (t) {
    var e = document.createElement("canvas"),
      a = 950 / t.width;
    (e.width = t.width * a), (e.height = t.height * a);
    var n = e.getContext("2d");
    (n.mozImageSmoothingEnabled = !0),
      (n.webkitImageSmoothingEnabled = !0),
      (n.msImageSmoothingEnabled = !0),
      (n.imageSmoothingEnabled = !0),
      n.drawImage(t, 0, 0, e.width, e.height);
    (t = Math.floor(112.2)),
      (e = (function (t) {
        var e = t.width,
          a = t.height,
          n = document.createElement("canvas");
        (n.width = e), (n.height = a);
        var o = n.getContext("2d");
        (o.fillStyle = "rgb(0,255,0)"), (o.strokeStyle = "rgb(0,255,0)"), o.drawImage(t, 0, 0, e, a);
        var r = o.getImageData(0, 0, e, a),
          i = new jsfeat.matrix_t(e, a, jsfeat.U8C1_t);
        jsfeat.imgproc.grayscale(r.data, e, a, i),
          (t = 50),
          (a = (1 + ((e = 0) | 4)) << 1),
          jsfeat.imgproc.gaussian_blur(i, i, a, 0),
          jsfeat.imgproc.canny(i, i, t, e);
        var pix;
        for (var h = 0, c = 0; c < r.data.length; c += 4, h++)
          (pix = i.data[h]), (r.data[c] = pix), (r.data[c + 1] = pix), (r.data[c + 2] = pix), (r.data[c + 3] = 255);
        return o.putImageData(r, 0, 0), n;
      })(e)),
      (t = points.getLocatePoints(e, t));
    return (
      console.log(
        "梯形校正座標(on Canvas):\r\n" +
          "左上: x=" +
          t[0].x +
          ", y=" +
          t[0].y +
          "\r\n" +
          "右上: x=" +
          t[2].x +
          ", y=" +
          t[2].y +
          "\r\n" +
          "右下: x=" +
          t[3].x +
          ", y=" +
          t[3].y +
          "\r\n" +
          "左下: x=" +
          t[1].x +
          ", y=" +
          t[1].y +
          "\r\n"
      ),
      [
        [t[0].x / a, t[0].y / a],
        [t[2].x / a, t[2].y / a],
        [t[3].x / a, t[3].y / a],
        [t[1].x / a, t[1].y / a],
      ]
    );
  },
  ResizeImage: function (t, e) {
    var a = document.createElement("canvas"),
      n = t.width * e,
      o = t.height * e;
    (a.width = n), (a.height = o);
    var r = a.getContext("2d");
    return (
      e < 0.7 &&
        ((r.mozImageSmoothingEnabled = !0), (r.webkitImageSmoothingEnabled = !0), (r.msImageSmoothingEnabled = !0), (r.imageSmoothingEnabled = !0)),
      r.drawImage(t, 0, 0, n, o),
      a
    );
  },
  ConvertToImage: function (t, e) {
    if ("png" !== e && "webp" !== e && "jpeg" !== e) return alert("不支援的壓縮格式：(" + e + ")"), null;
    var a = "image/" + e,
      e = document.createElement("canvas");
    (e.width = t.width), (e.height = t.height);
    e.getContext("2d").drawImage(t, 0, 0);
    (e = e.toDataURL(a, 80)), (a = new Image());
    return (a.src = e), (a.width = t.width), (a.height = t.height), a;
  },
  ConvertHEIC: function (n, o) {
    return new Promise((e, a) => {
      var t = o.toLowerCase();
      "png" == t || "jpeg" == t
        ? heic2any({ blob: n, quality: 0.8, toType: "image/" + t })
            .then(function (t) {
              e(t);
            })
            .catch(function (t) {
              a("轉換失敗：(" + t.message + ")");
            })
        : a("不支援的輸出格式：(" + t + ")");
    });
  },
  RotateImage: function (t, e) {
    var a = t.width,
      n = t.height,
      o = 0,
      r = 0,
      i = 0,
      h = 0,
      c = 0,
      g = 0,
      l = t.getContext("2d").getImageData(0, 0, a, n).data,
      t = document.createElement("canvas");
    var pNewBuff;
    if (180 == e || -180 == e) {
      (c = a), (g = n), (t.width = c), (t.height = g);
      var d = t.getContext("2d").getImageData(0, 0, c, g);
      pNewBuff = d.data;
      for (var s, u, r = 0; r < n; r++)
        for (s = 4 * a * r, u = 4 * a * (n - r - 1), o = 0; o < a; o++)
          (i = s + 4 * o),
            (h = u + 4 * (a - 1 - o)),
            (pNewBuff[h] = l[i]),
            (pNewBuff[h + 1] = l[i + 1]),
            (pNewBuff[h + 2] = l[i + 2]),
            (pNewBuff[h + 3] = l[i + 3]);
    } else if (90 == e || -270 == e) {
      (c = n), (g = a), (t.width = c), (t.height = g);
      d = t.getContext("2d").getImageData(0, 0, c, g);
      pNewBuff = d.data;
      var f = 4 * a,
        m = 4 * c;
      for (r = 0; r < n; r++)
        for (o = 0; o < a; o++)
          (i = r * f + 4 * o),
            (h = o * m + 4 * (c - r - 1)),
            (pNewBuff[h] = l[i]),
            (pNewBuff[h + 1] = l[i + 1]),
            (pNewBuff[h + 2] = l[i + 2]),
            (pNewBuff[h + 3] = l[i + 3]);
    } else {
      if (270 != e && -90 != e) return void alert("不支援的旋轉角度：" + e);
      (c = n), (g = a), (t.width = c), (t.height = g);
      d = t.getContext("2d").getImageData(0, 0, c, g);
      pNewBuff = d.data;
      (f = 4 * a), (m = 4 * c);
      for (r = 0; r < n; r++)
        for (o = 0; o < a; o++)
          (i = r * f + 4 * o),
            (h = (g - o - 1) * m + 4 * r),
            (pNewBuff[h] = l[i]),
            (pNewBuff[h + 1] = l[i + 1]),
            (pNewBuff[h + 2] = l[i + 2]),
            (pNewBuff[h + 3] = l[i + 3]);
    }
    return t.getContext("2d").putImageData(d, 0, 0), t;
  },
};
export default cgimg;
